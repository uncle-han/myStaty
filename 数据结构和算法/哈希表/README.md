# 哈希表
### 1. 通过问题认识哈希表
案例：将50000个单词，通过某种数据结构存储，并通过单词名称找出对于单词的读音，翻译，应用。

---
* 链表？
增加简单，但是查找线性查找。可能有5000次查找，效率低
---
* 数组？
通过单词名线性查找，可能有5000次查找，效率低
但是数组通过下标查找很快
可以不可以将某个单词，转换成下标之后，再按照下标存储到数组中。等查找某个单词的时候。
---
***哈希函数***概念：将某个值转换成某个数字，由于存储到数组中

### 将字符串转成数字
#### 方案1：每个字母对应的数字相加，
类似于ascll码：
a 在ascll中的排序是97，
A 在ascll中的排序是65

由此类推。我们可以设计一套自己的编码风格
比如：
*  `a => 0`
*  `b => 1`

以此类推
* `z => 25`

如单词cats 是 3 + 1 + 20 + 19 = 43

则将43作为下标存到数组中

会引发另外一个问题
was/tin/tend/moan/tick哈希函数之后的值都是43，最后覆盖掉之前的值

#### 方案2：幂的连乘
如单词cats 
```js
// cats
const res =  3 * Math.pow(25, 3) + 1 * Math.pow(25, 2) + 20 * Math.pow(25, 1) + 19 * Math.pow(25, 0)
```
则cats的单词幂的连乘为：48019

假如一个单词最多10个字母zzzzzzzzzz，则单词幂的连乘将会是一个非常大的数字，可能比7000000000000000还要大，相比较于单词zzzzzzzzzy哈希函数之后，相差很大，中间是不会有其他单词存在的，也不可能创建长度为7000000000000000的数组。造成一个空间的浪费
## 哈希函数化的优化。
假如总共有5万个单词。
某一个单词`xxxxxx`哈希函数之后，是149999，对这个数字进行一个范围取余，过程叫做哈希化。公式是：`largeNumber % rangeNumber`
由公式得：149999 % 50000 = 49999

则将149999的这个单词映射在范围是50000的第49999的位置

---

***哈希化***概念：将某个巨大的数字，用某个范围的值来取余，得到一个在某个范围的内的数字。这个过程叫做哈希化

单词melioration和demysttify的下标是一样的

但哈希化之后的下标，在哈希表已经存在，这种情况叫做**哈希碰撞**

**大数字哈希之后也有可能会重复(概率很小)，该如何解决可能会出现的重复呢？**

---
### 解决哈希碰撞的方法：链地址法(拉链法)




